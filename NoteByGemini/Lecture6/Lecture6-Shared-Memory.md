### 模板B: 特定术语/技术

#### 1. 定义 (Definition)
**共享内存 (Shared Memory)** 是 **[GPU 架构](./Lecture6-GPU-Architecture.md)** 中一种特殊的片上内存 (On-chip Memory). 它位于每个**流式多处理器 (SM)** 的内部, 其访问速度非常快, 几乎与 L1 缓存和寄存器处于同一量级, 远快于 GPU 的全局内存 (DRAM). 

它的核心特性是“共享”:**同一[线程块 (Thread Block)](./Lecture6-GPU-Execution-Model.md)内的所有线程都可以访问同一块共享内存**. 这使得共享内存成为线程块内部进行高效数据交换、协作和通信的主要媒介. 

#### 2. 关键特性与用途 (Key Features & Usage)
*   **高速**:访问延迟极低, 带宽极高. 是实现高性能计算的关键. 
*   **块内共享**:其作用域严格限制在单个线程块内. 一个线程块无法访问另一个线程块的共享内存. 这种设计保证了线程块的独立性和程序的可扩展性. 
*   **程序员可控**:与 L1/L2 缓存不同, 共享内存是由程序员在 Kernel 代码中**显式声明和管理**的. 开发者需要明确地将数据从全局内存加载到共享内存, 然后再从共享内存中读取以进行计算. 
*   **容量有限**:共享内存的容量非常有限(例如, 在 A100 GPU 上, 每个 SM 的 L1/共享内存总共约 192KB, 可配置给共享内存的部分通常在几十KB). 因此, 它只能用作临时的高速暂存区. 
*   **主要用途**:
    1.  **提高数据复用率**:这是共享内存最重要的用途. 通过将需要被一个线程块内多个线程反复访问的数据从全局内存加载到共享内存, 可以避免多次昂贵的全局内存读取. **[矩阵乘法分块](./Lecture6-Matrix-Multiplication-Tiling.md)**是这一用途的典范. 
    2.  **实现并行算法**:许多并行算法, 如归约 (Reduction)、扫描 (Scan)、直方图计算 (Histogram) 等, 都依赖共享内存来实现线程间的数据交换和协作. 
    3.  **避免非合并内存访问**:对于某些不连续的全局内存访问模式, 可以先将数据以合并方式加载到共享内存, 然后在共享内存中进行不规则的访问, 从而提高内存访问效率. 

#### 3. 与其他内存的关系 (Relation to Other Memory)
*   **vs. 全局内存 (DRAM)**:速度快得多, 但容量小得多. 共享内存是作为全局内存的高速缓存或暂存区来使用的. 
*   **vs. 寄存器 (Registers)**:速度相当, 但寄存器是每个线程**私有**的, 而共享内存是线程块内**共享**的. 
*   **vs. L1 缓存 (L1 Cache)**:物理上, 共享内存和 L1 缓存通常共享同一块 SRAM. 它们之间的容量分配通常是可配置的. L1 缓存对程序员是**透明**的(自动缓存), 而共享内存需要**显式**管理. 

**编程注意事项**:
*   **Bank Conflict (存储体冲突)**:共享内存被划分为多个等宽的存储体 (bank). 如果一个 Warp 内的多个线程同时访问同一个 bank(除了广播读取同一地址), 就会发生冲突, 导致访问被串行化, 严重降低性能. 编写高效的共享内存代码需要仔细设计内存访问模式以避免冲突. **[Triton](./Lecture6-Triton.md)** 等现代工具的编译器会帮助开发者自动处理或规避许多这类问题. 